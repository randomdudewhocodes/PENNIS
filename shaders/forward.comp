#version 450

layout(constant_id = 0) const uint workgroupSize = 256;
layout(local_size_x_id = 0) in;

layout(set = 0, binding = 0) readonly  buffer Weights { float W[]; };
layout(set = 0, binding = 1) readonly  buffer Biases  { float B[]; };
layout(set = 0, binding = 2) readonly  buffer Inputs  { float X[]; };
layout(set = 0, binding = 3) writeonly buffer PreActs { float Z[]; };
layout(set = 0, binding = 4) writeonly buffer Acts    { float A[]; };

layout(push_constant) uniform PushConstants {
    uint inSize, outSize, batchSize, actType;
} push;

float activate(float x)
{
    switch (push.actType)
    {
        case 1: return max(x, 0);
        case 2: return 1 / (1 + exp(-x));
        case 3: return tanh(x);
        case 4: return sin(x);
        default: return x;
    }
}

void main()
{
    
    uint id = gl_GlobalInvocationID.x;
    if(id >= push.outSize * push.batchSize) return;

    uint neuron = id % push.outSize;
    uint batch  = id / push.outSize;

    float z = B[neuron];

    for (uint i = 0; i < push.inSize; i++)
        z += X[batch * push.inSize + i] * W[neuron * push.inSize + i];
    
    Z[id] = z;
    A[id] = activate(z);
}